#include <bits/stdc++.h>
#include <queue>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n)-1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n)-1; (i) >= (int)(m); --(i))
#define PB push_back
#define SH std::cout <<
#define LN << '\n'
#define RD std::cin >>
#define va std::vector<auto>

using namespace std;
typedef std::vector<int> vi;
template <typename _A, typename _B> using umap = unordered_map<_A, _B>;
template <typename T> using v = vector<T>;

template <typename T> void RD_VC(v<T> &a, int n) {}

void solve(v<vi> &b) {
  int n = b.size();
  int dn = 2 * n - 1;
  // along diagonal
  vi d1(dn, 0);
  for (int i = 0; i < dn; ++i) {
    int x = i - n + 1;
    int y = 0;
    if (x < 0) {
      y = -x;
      x = 0;
    }
    while (x < n && y < n) {
      d1[i] += b[x][y];
      ++x;
      ++y;
    }
  }

  // along other diagonal
  vi d2(dn, 0);
  for (int i = 0; i < dn; ++i) {
    int y = i;
    int x = 0;
    if (y >= n) {
      x = y - n + 1;
      y = n - 1;
    }

    while (x < n && y >= 0) {
      d2[i] += b[x][y];
      ++x;
      --y;
    }
  }
  priority_queue<pair<int, pair<int, int>>> pq;
  for (int i = 0; i < n; ++i) {
    for (int j = 0; j < n; ++j) {
      // find the index of the diagonal for element (i, j)
      int idx2 = i + j;
      int idx1 = i - j + n - 1;
      // no double counting of i j
      pq.push({d1[idx1] + d2[idx2] - b[i][j], {i, j}});
    }
  }
  auto p1 = pq.top();
  pq.pop();
  auto p2 = pq.top();
  pq.pop();

  int money = p1.first + p2.first;

  cout << money LN;
  cout << p1.second.second + 1 << " " << p1.second.first + 1 << ' ';
  cout << p2.second.second + 1 << " " << p2.second.first + 1 << endl;
}

// generated by oj-template v4.8.1
// (https://github.com/online-judge-tools/template-generator)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int a;
  std::cin >> a;
  v<vi> b(a);
  REP(i, a) { b[i].resize(a); }
  REP(i, a) {
    REP(j, a) { std::cin >> b[j][i]; }
  }
  solve(b);
  return 0;
}
