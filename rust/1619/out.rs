fn solve() {
    input! {
        n: i,
        a: [i; n],
    }

    a.sort_unstable();

    let mut st = vii::new();
    let mut cost = 0;
    let mut idx = 0;
    for i in 0..=n {
        if i != 0 {
            if let Some((val, freq)) = st.pop() {
                cost += i - 1 - val;
                if freq > 1 {
                    st.push((val, freq - 1));
                }
            } else {
                ans!((i..=n).map(|_| -1),*);
            }
        }

        let mut freq = 0;
        while idx < n && a[idx.u()] == i {
            freq += 1;
            idx += 1;
        }
        if freq > 0 {
            st.push((i, freq));
        }

        let cost = cost + freq;
        print!("{} ", cost);
    }

    println!();
}

main!(multi);

#[cfg(not(ONLINE_JUDGE))]
#[macro_use]
extern crate cp;

#[cfg(not(ONLINE_JUDGE))]
use cp::*;
// =================================================================================
// =================================================================================

// LIBRARY CODE BEGINS HERE
// TAKEN FROM https://github.com/EbTech/rust-algorithms
// YOU CAN JUST RUN rustfmt TO GET READABLE CODE

// =================================================================================
// =================================================================================
pub use std::cmp::*; pub use std::collections::*; pub use std::io::*; pub use std::mem::*; pub use std::str::FromStr; pub type i = i64; pub type u = usize; pub type v<T> = Vec<T>; pub type ii = (i64, i64); pub type vi = v<i>; pub type vii = v<ii>; use std::{ fmt::Display, intrinsics::transmute, io::{self, StdinLock}, mem::MaybeUninit, }; pub mod algo { pub mod caching { use std::collections::HashMap; pub struct Cacher<F, U, V> where F: Fn(U) -> V, U: std::cmp::Eq + std::hash::Hash + Copy, V: Copy, { calculation: F, values: HashMap<U, V>, } impl<F, U, V> Cacher<F, U, V> where F: Fn(U) -> V, U: std::cmp::Eq + std::hash::Hash + Copy, V: Copy, { pub fn new(calculation: F) -> Cacher<F, U, V> { Cacher { calculation, values: HashMap::new(), } } pub fn call(&mut self, arg: U) -> V { let calc = &self.calculation; *self.values.entry(arg).or_insert_with_key(|&key| calc(key)) } pub fn call_and_replace(&mut self, arg: U) -> V { let new_val = (self.calculation)(arg); self.values.insert(arg, new_val); new_val } } } pub mod graph { pub mod connectivity { use super::Graph; struct ConnectivityData { time: usize, vis: Box<[usize]>, low: Box<[usize]>, v_stack: Vec<usize>, e_stack: Vec<usize>, } impl ConnectivityData { fn new(num_v: usize) -> Self { Self { time: 0, vis: vec![0; num_v].into_boxed_slice(), low: vec![0; num_v].into_boxed_slice(), v_stack: vec![], e_stack: vec![], } } fn visit(&mut self, u: usize) { self.time += 1; self.vis[u] = self.time; self.low[u] = self.time; self.v_stack.push(u); } fn lower(&mut self, u: usize, val: usize) { if self.low[u] > val { self.low[u] = val } } } pub struct ConnectivityGraph<'a> { pub graph: &'a Graph, pub cc: Vec<usize>, pub vcc: Vec<usize>, pub num_cc: usize, pub num_vcc: usize, } impl<'a> ConnectivityGraph<'a> { pub fn new(graph: &'a Graph, is_directed: bool) -> Self { let mut connect = Self { graph, cc: vec![0; graph.num_v()], vcc: vec![0; graph.num_e()], num_cc: 0, num_vcc: 0, }; let mut data = ConnectivityData::new(graph.num_v()); for u in 0..graph.num_v() { if data.vis[u] == 0 { if is_directed { connect.scc(&mut data, u); } else { connect.bcc(&mut data, u, graph.num_e() + 1); } } } connect } fn scc(&mut self, data: &mut ConnectivityData, u: usize) { data.visit(u); for (_, v) in self.graph.adj_list(u) { if data.vis[v] == 0 { self.scc(data, v); } if self.cc[v] == 0 { data.lower(u, data.low[v]); } } if data.vis[u] == data.low[u] { self.num_cc += 1; while let Some(v) = data.v_stack.pop() { self.cc[v] = self.num_cc; if v == u { break; } } } } pub fn two_sat_assign(&self) -> Option<Vec<bool>> { (0..self.graph.num_v() / 2) .map(|i| { let scc_true = self.cc[2 * i]; let scc_false = self.cc[2 * i + 1]; if scc_true == scc_false { None } else { Some(scc_true < scc_false) } }) .collect() } pub fn topological_sort(&self) -> Vec<usize> { let mut vertices = (0..self.graph.num_v()).collect::<Vec<_>>(); vertices.sort_unstable_by_key(|&u| self.num_cc - self.cc[u]); vertices } fn bcc(&mut self, data: &mut ConnectivityData, u: usize, par: usize) { data.visit(u); for (e, v) in self.graph.adj_list(u) { if data.vis[v] == 0 { data.e_stack.push(e); self.bcc(data, v, e); data.lower(u, data.low[v]); if data.vis[u] <= data.low[v] { self.num_vcc += 1; while let Some(top_e) = data.e_stack.pop() { self.vcc[top_e] = self.num_vcc; self.vcc[top_e ^ 1] = self.num_vcc; if e ^ top_e <= 1 { break; } } } } else if data.vis[v] < data.vis[u] && e ^ par != 1 { data.lower(u, data.vis[v]); data.e_stack.push(e); } else if v == u { self.num_vcc += 1; self.vcc[e] = self.num_vcc; self.vcc[e ^ 1] = self.num_vcc; } } if data.vis[u] == data.low[u] { self.num_cc += 1; while let Some(v) = data.v_stack.pop() { self.cc[v] = self.num_cc; if v == u { break; } } } } pub fn is_cut_vertex(&self, u: usize) -> bool { if let Some(first_e) = self.graph.first[u] { self.graph .adj_list(u) .any(|(e, _)| self.vcc[first_e] != self.vcc[e]) } else { false } } pub fn is_cut_edge(&self, e: usize) -> bool { let u = self.graph.endp[e ^ 1]; let v = self.graph.endp[e]; self.cc[u] != self.cc[v] } } } pub mod flow { use super::{AdjListIterator, Graph}; pub struct FlowGraph { pub graph: Graph, pub cap: Vec<i64>, pub cost: Vec<i64>, } impl FlowGraph { const INF: i64 = i64::MAX; pub fn new(vmax: usize, emax_hint: usize) -> Self { Self { graph: Graph::new(vmax, 2 * emax_hint), cap: Vec::with_capacity(2 * emax_hint), cost: Vec::with_capacity(2 * emax_hint), } } pub fn add_edge(&mut self, u: usize, v: usize, cap: i64, rcap: i64, cost: i64) { self.cap.push(cap); self.cap.push(rcap); self.cost.push(cost); self.cost.push(-cost); self.graph.add_undirected_edge(u, v); } pub fn dinic(&self, s: usize, t: usize) -> (i64, Vec<i64>) { let mut flow = vec![0; self.graph.num_e()]; let mut max_flow = 0; loop { let dist = self.dinic_search(s, &flow); if dist[t] == Self::INF { break; } let mut adj_iters = (0..self.graph.num_v()) .map(|u| self.graph.adj_list(u).peekable()) .collect::<Vec<_>>(); max_flow += self.dinic_augment(s, t, Self::INF, &dist, &mut adj_iters, &mut flow); } (max_flow, flow) } fn dinic_search(&self, s: usize, flow: &[i64]) -> Vec<i64> { let mut dist = vec![Self::INF; self.graph.num_v()]; let mut q = ::std::collections::VecDeque::new(); dist[s] = 0; q.push_back(s); while let Some(u) = q.pop_front() { for (e, v) in self.graph.adj_list(u) { if dist[v] == Self::INF && flow[e] < self.cap[e] { dist[v] = dist[u] + 1; q.push_back(v); } } } dist } fn dinic_augment( &self, u: usize, t: usize, f: i64, dist: &[i64], adj: &mut [::std::iter::Peekable<AdjListIterator>], flow: &mut [i64], ) -> i64 { if u == t { return f; } let mut df = 0; while let Some(&(e, v)) = adj[u].peek() { let rem_cap = (self.cap[e] - flow[e]).min(f - df); if rem_cap > 0 && dist[v] == dist[u] + 1 { let cf = self.dinic_augment(v, t, rem_cap, dist, adj, flow); flow[e] += cf; flow[e ^ 1] -= cf; df += cf; if df == f { break; } } adj[u].next(); } df } pub fn min_cut(&self, dist: &[i64]) -> Vec<usize> { (0..self.graph.num_e()) .filter(|&e| { let u = self.graph.endp[e ^ 1]; let v = self.graph.endp[e]; dist[u] < Self::INF && dist[v] == Self::INF }) .collect() } pub fn mcf(&self, s: usize, t: usize) -> (i64, i64, Vec<i64>) { let mut pot = vec![0; self.graph.num_v()]; for _ in 1..self.graph.num_v() { for e in 0..self.graph.num_e() { if self.cap[e] > 0 { let u = self.graph.endp[e ^ 1]; let v = self.graph.endp[e]; pot[v] = pot[v].min(pot[u] + self.cost[e]); } } } let mut flow = vec![0; self.graph.num_e()]; let (mut min_cost, mut max_flow) = (0, 0); loop { let par = self.mcf_search(s, &flow, &mut pot); if par[t] == None { break; } let (dc, df) = self.mcf_augment(t, &par, &mut flow); min_cost += dc; max_flow += df; } (min_cost, max_flow, flow) } fn mcf_search( &self, s: usize, flow: &[i64], pot: &mut [i64], ) -> Vec<Option<usize>> { let mut vis = vec![false; self.graph.num_v()]; let mut dist = vec![Self::INF; self.graph.num_v()]; let mut par = vec![None; self.graph.num_v()]; dist[s] = 0; while let Some(u) = (0..self.graph.num_v()) .filter(|&u| !vis[u] && dist[u] < Self::INF) .min_by_key(|&u| dist[u] - pot[u]) { vis[u] = true; pot[u] = dist[u]; for (e, v) in self.graph.adj_list(u) { if dist[v] > dist[u] + self.cost[e] && flow[e] < self.cap[e] { dist[v] = dist[u] + self.cost[e]; par[v] = Some(e); } } } par } fn mcf_augment( &self, t: usize, par: &[Option<usize>], flow: &mut [i64], ) -> (i64, i64) { let (mut dc, mut df) = (0, Self::INF); let mut u = t; while let Some(e) = par[u] { df = df.min(self.cap[e] - flow[e]); u = self.graph.endp[e ^ 1]; } u = t; while let Some(e) = par[u] { flow[e] += df; flow[e ^ 1] -= df; dc += df * self.cost[e]; u = self.graph.endp[e ^ 1]; } (dc, df) } } } pub mod util { use super::AdjListIterator; use super::{DisjointSets, Graph}; use std::cmp::Reverse; impl Graph { pub fn euler_path(&self, u: usize) -> Vec<usize> { let mut adj_iters = (0..self.num_v()) .map(|u| self.adj_list(u)) .collect::<Vec<_>>(); let mut edges = Vec::with_capacity(self.num_e()); self.euler_recurse(u, &mut adj_iters, &mut edges); edges.reverse(); edges } fn euler_recurse( &self, u: usize, adj: &mut [AdjListIterator], edges: &mut Vec<usize>, ) { while let Some((e, v)) = adj[u].next() { self.euler_recurse(v, adj, edges); edges.push(e); } } pub fn min_spanning_tree(&self, weights: &[i64]) -> Vec<usize> { assert_eq!(self.num_e(), 2 * weights.len()); let mut edges = (0..weights.len()).collect::<Vec<_>>(); edges.sort_unstable_by_key(|&e| weights[e]); let mut components = DisjointSets::new(self.num_v()); edges .into_iter() .filter(|&e| components.merge(self.endp[2 * e], self.endp[2 * e + 1])) .collect() } pub fn dijkstra(&self, weights: &[u64], u: usize) -> Vec<u64> { assert_eq!(self.num_e(), weights.len()); let mut dist = vec![u64::max_value(); weights.len()]; let mut heap = std::collections::BinaryHeap::new(); dist[u] = 0; heap.push((Reverse(0), 0)); while let Some((Reverse(dist_u), u)) = heap.pop() { if dist[u] == dist_u { for (e, v) in self.adj_list(u) { let dist_v = dist_u + weights[e]; if dist[v] > dist_v { dist[v] = dist_v; heap.push((Reverse(dist_v), v)); } } } } dist } pub fn dfs(&self, root: usize) -> DfsIterator { let mut visited = vec![false; self.num_v()]; visited[root] = true; let adj_iters = (0..self.num_v()) .map(|u| self.adj_list(u)) .collect::<Vec<_>>(); DfsIterator { visited, stack: vec![root], adj_iters, } } } pub struct DfsIterator<'a> { visited: Vec<bool>, stack: Vec<usize>, adj_iters: Vec<AdjListIterator<'a>>, } impl<'a> Iterator for DfsIterator<'a> { type Item = (usize, usize); fn next(&mut self) -> Option<Self::Item> { loop { let &u = self.stack.last()?; while let Some((e, v)) = self.adj_iters[u].next() { if !self.visited[v] { self.visited[v] = true; self.stack.push(v); return Some((e, v)); } } self.stack.pop(); } } } } pub struct DisjointSets { parent: Vec<usize>, } impl DisjointSets { pub fn new(size: usize) -> Self { Self { parent: (0..size).collect(), } } pub fn find(&mut self, u: usize) -> usize { let pu = self.parent[u]; if pu != u { self.parent[u] = self.find(pu); } self.parent[u] } pub fn merge(&mut self, u: usize, v: usize) -> bool { let (pu, pv) = (self.find(u), self.find(v)); self.parent[pu] = pv; pu != pv } } pub struct Graph { first: Vec<Option<usize>>, next: Vec<Option<usize>>, endp: Vec<usize>, } impl Graph { pub fn new(vmax: usize, emax_hint: usize) -> Self { Self { first: vec![None; vmax], next: Vec::with_capacity(emax_hint), endp: Vec::with_capacity(emax_hint), } } pub fn num_v(&self) -> usize { self.first.len() } pub fn num_e(&self) -> usize { self.endp.len() } pub fn add_edge(&mut self, u: usize, v: usize) { self.next.push(self.first[u]); self.first[u] = Some(self.num_e()); self.endp.push(v); } pub fn add_undirected_edge(&mut self, u: usize, v: usize) { self.add_edge(u, v); self.add_edge(v, u); } pub fn add_two_sat_clause(&mut self, u: usize, v: usize) { self.add_edge(u ^ 1, v); self.add_edge(v ^ 1, u); } pub fn adj_list(&self, u: usize) -> AdjListIterator { AdjListIterator { graph: self, next_e: self.first[u], } } } pub struct AdjListIterator<'a> { graph: &'a Graph, next_e: Option<usize>, } impl<'a> Iterator for AdjListIterator<'a> { type Item = (usize, usize); fn next(&mut self) -> Option<Self::Item> { self.next_e.map(|e| { let v = self.graph.endp[e]; self.next_e = self.graph.next[e]; (e, v) }) } } } pub mod math { pub mod fft { use super::num::{CommonField, Complex, PI}; use std::ops::{Add, Div, Mul, Neg, Sub}; struct BitRevIterator { a: usize, n: usize, } impl BitRevIterator { fn new(n: usize) -> Self { assert!(n.is_power_of_two()); Self { a: 2 * n - 1, n } } } impl Iterator for BitRevIterator { type Item = usize; fn next(&mut self) -> Option<Self::Item> { if self.a == 2 * self.n - 2 { return None; } let mut mask = self.n; while self.a & mask > 0 { self.a ^= mask; mask /= 2; } self.a |= mask; Some(self.a / 2) } } #[allow(clippy::upper_case_acronyms)] pub trait FFT: Sized + Copy { type F: Sized + Copy + From<Self> + Neg + Add<Output = Self::F> + Div<Output = Self::F> + Mul<Output = Self::F> + Sub<Output = Self::F>; const ZERO: Self; fn get_roots(n: usize, inverse: bool) -> Vec<Self::F>; fn get_factor(n: usize, inverse: bool) -> Self::F; fn extract(f: Self::F) -> Self; } impl FFT for f64 { type F = Complex; const ZERO: f64 = 0.0; fn get_roots(n: usize, inverse: bool) -> Vec<Self::F> { let step = if inverse { -2.0 } else { 2.0 } * PI / n as f64; (0..n / 2) .map(|i| Complex::from_polar(1.0, step * i as f64)) .collect() } fn get_factor(n: usize, inverse: bool) -> Self::F { Self::F::from(if inverse { (n as f64).recip() } else { 1.0 }) } fn extract(f: Self::F) -> f64 { f.real } } impl FFT for i64 { type F = CommonField; const ZERO: Self = 0; fn get_roots(n: usize, inverse: bool) -> Vec<Self::F> { assert!(n <= 1 << 23); let mut prim_root = Self::F::from(15_311_432); if inverse { prim_root = prim_root.recip(); } for _ in (0..).take_while(|&i| n < 1 << (23 - i)) { prim_root = prim_root * prim_root; } let mut roots = Vec::with_capacity(n / 2); let mut root = Self::F::from(1); for _ in 0..roots.capacity() { roots.push(root); root = root * prim_root; } roots } fn get_factor(n: usize, inverse: bool) -> Self::F { Self::F::from(if inverse { n as Self } else { 1 }).recip() } fn extract(f: Self::F) -> Self { f.val } } pub fn fft<T: FFT>(v: &[T::F], inverse: bool) -> Vec<T::F> { let n = v.len(); assert!(n.is_power_of_two()); let factor = T::get_factor(n, inverse); let roots_of_unity = T::get_roots(n, inverse); let mut dft = BitRevIterator::new(n) .map(|i| v[i] * factor) .collect::<Vec<_>>(); for m in (0..).map(|s| 1 << s).take_while(|&m| m < n) { for k in (0..n).step_by(2 * m) { for j in 0..m { let u = dft[k + j]; let t = dft[k + j + m] * roots_of_unity[n / 2 / m * j]; dft[k + j] = u + t; dft[k + j + m] = u - t; } } } dft } pub fn dft_from_reals<T: FFT>(v: &[T], desired_len: usize) -> Vec<T::F> { assert!(v.len() <= desired_len); let complex_v = v .iter() .cloned() .chain(std::iter::repeat(T::ZERO)) .take(desired_len.next_power_of_two()) .map(T::F::from) .collect::<Vec<_>>(); fft::<T>(&complex_v, false) } pub fn idft_to_reals<T: FFT>(dft_v: &[T::F], desired_len: usize) -> Vec<T> { assert!(dft_v.len() >= desired_len); let complex_v = fft::<T>(dft_v, true); complex_v .into_iter() .take(desired_len) .map(T::extract) .collect() } pub fn convolution<T: FFT>(a: &[T], b: &[T]) -> Vec<T> { let len_c = a.len() + b.len() - 1; let dft_a = dft_from_reals(a, len_c).into_iter(); let dft_b = dft_from_reals(b, len_c).into_iter(); let dft_c = dft_a.zip(dft_b).map(|(a, b)| a * b).collect::<Vec<_>>(); idft_to_reals(&dft_c, len_c) } } pub mod num { pub use std::f64::consts::PI; use std::ops::{Add, Div, Index, IndexMut, Mul, Neg, Sub}; pub fn fast_gcd(mut a: i64, mut b: i64) -> i64 { while b != 0 { a %= b; std::mem::swap(&mut a, &mut b); } a.abs() } #[derive(Clone, Copy, Eq, PartialEq, Debug, Hash)] pub struct Rational { pub num: i64, pub den: i64, } impl Rational { pub fn new(num: i64, den: i64) -> Self { let g = fast_gcd(num, den) * den.signum(); Self { num: num / g, den: den / g, } } pub fn abs(self) -> Self { Self { num: self.num.abs(), den: self.den, } } pub fn recip(self) -> Self { let g = self.num.signum(); Self { num: self.den / g, den: self.num / g, } } } impl From<i64> for Rational { fn from(num: i64) -> Self { Self { num, den: 1 } } } impl Neg for Rational { type Output = Self; fn neg(self) -> Self { Self { num: -self.num, den: self.den, } } } #[allow(clippy::suspicious_arithmetic_impl)] impl Add for Rational { type Output = Self; fn add(self, other: Self) -> Self { Self::new( self.num * other.den + self.den * other.num, self.den * other.den, ) } } #[allow(clippy::suspicious_arithmetic_impl)] impl Sub for Rational { type Output = Self; fn sub(self, other: Self) -> Self { Self::new( self.num * other.den - self.den * other.num, self.den * other.den, ) } } impl Mul for Rational { type Output = Self; fn mul(self, other: Self) -> Self { Self::new(self.num * other.num, self.den * other.den) } } #[allow(clippy::suspicious_arithmetic_impl)] impl Div for Rational { type Output = Self; fn div(self, other: Self) -> Self { self * other.recip() } } impl Ord for Rational { fn cmp(&self, other: &Self) -> std::cmp::Ordering { (self.num * other.den).cmp(&(self.den * other.num)) } } impl PartialOrd for Rational { fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> { Some(self.cmp(other)) } } #[derive(Clone, Copy, PartialEq, Debug)] pub struct Complex { pub real: f64, pub imag: f64, } impl Complex { pub fn new(real: f64, imag: f64) -> Self { Self { real, imag } } pub fn from_polar(r: f64, th: f64) -> Self { Self::new(r * th.cos(), r * th.sin()) } pub fn abs_square(self) -> f64 { self.real * self.real + self.imag * self.imag } pub fn argument(self) -> f64 { self.imag.atan2(self.real) } pub fn conjugate(self) -> Self { Self::new(self.real, -self.imag) } pub fn recip(self) -> Self { let denom = self.abs_square(); Self::new(self.real / denom, -self.imag / denom) } } impl From<f64> for Complex { fn from(real: f64) -> Self { Self::new(real, 0.0) } } impl Neg for Complex { type Output = Self; fn neg(self) -> Self { Self::new(-self.real, -self.imag) } } impl Add for Complex { type Output = Self; fn add(self, other: Self) -> Self { Self::new(self.real + other.real, self.imag + other.imag) } } impl Sub for Complex { type Output = Self; fn sub(self, other: Self) -> Self { Self::new(self.real - other.real, self.imag - other.imag) } } impl Mul for Complex { type Output = Self; fn mul(self, other: Self) -> Self { let real = self.real * other.real - self.imag * other.imag; let imag = self.imag * other.real + self.real * other.imag; Self::new(real, imag) } } #[allow(clippy::suspicious_arithmetic_impl)] impl Div for Complex { type Output = Self; fn div(self, other: Self) -> Self { self * other.recip() } } #[derive(Clone, Copy, Eq, PartialEq, Debug, Hash)] pub struct Modulo<const M: i64> { pub val: i64, } impl<const M: i64> Modulo<M> { pub fn pow(mut self, mut n: u64) -> Self { let mut result = Self::from_small(1); while n > 0 { if n % 2 == 1 { result = result * self; } self = self * self; n /= 2; } result } pub fn vec_of_recips(n: i64) -> Vec<Self> { let mut recips = vec![Self::from(0), Self::from(1)]; for i in 2..=n { let (md, dv) = (M % i, M / i); recips.push(recips[md as usize] * Self::from_small(-dv)); } recips } pub fn recip(self) -> Self { self.pow(M as u64 - 2) } fn from_small(s: i64) -> Self { let val = if s < 0 { s + M } else { s }; Self { val } } } impl<const M: i64> From<i64> for Modulo<M> { fn from(val: i64) -> Self { Self::from_small(val % M) } } impl<const M: i64> Neg for Modulo<M> { type Output = Self; fn neg(self) -> Self { Self::from_small(-self.val) } } impl<const M: i64> Add for Modulo<M> { type Output = Self; fn add(self, other: Self) -> Self { Self::from_small(self.val + other.val - M) } } impl<const M: i64> Sub for Modulo<M> { type Output = Self; fn sub(self, other: Self) -> Self { Self::from_small(self.val - other.val) } } impl<const M: i64> Mul for Modulo<M> { type Output = Self; fn mul(self, other: Self) -> Self { Self::from(self.val * other.val) } } #[allow(clippy::suspicious_arithmetic_impl)] impl<const M: i64> Div for Modulo<M> { type Output = Self; fn div(self, other: Self) -> Self { self * other.recip() } } pub const COMMON_PRIME: i64 = 998_244_353; pub type CommonField = Modulo<COMMON_PRIME>; #[derive(Clone, PartialEq, Debug)] pub struct Matrix { cols: usize, inner: Box<[f64]>, } impl Matrix { pub fn zero(rows: usize, cols: usize) -> Self { let inner = vec![0.0; rows * cols].into_boxed_slice(); Self { cols, inner } } pub fn one(cols: usize) -> Self { let mut matrix = Self::zero(cols, cols); for i in 0..cols { matrix[i][i] = 1.0; } matrix } pub fn vector(vec: &[f64], as_row: bool) -> Self { let cols = if as_row { vec.len() } else { 1 }; let inner = vec.to_vec().into_boxed_slice(); Self { cols, inner } } pub fn pow(&self, mut n: u64) -> Self { let mut base = self.clone(); let mut result = Self::one(self.cols); while n > 0 { if n % 2 == 1 { result = &result * &base; } base = &base * &base; n /= 2; } result } pub fn rows(&self) -> usize { self.inner.len() / self.cols } pub fn transpose(&self) -> Self { let mut matrix = Matrix::zero(self.cols, self.rows()); for i in 0..self.rows() { for j in 0..self.cols { matrix[j][i] = self[i][j]; } } matrix } pub fn recip(&self) -> Self { unimplemented!(); } } impl Index<usize> for Matrix { type Output = [f64]; fn index(&self, row: usize) -> &Self::Output { let start = self.cols * row; &self.inner[start..start + self.cols] } } impl IndexMut<usize> for Matrix { fn index_mut(&mut self, row: usize) -> &mut Self::Output { let start = self.cols * row; &mut self.inner[start..start + self.cols] } } impl Neg for &Matrix { type Output = Matrix; fn neg(self) -> Matrix { let inner = self.inner.iter().map(|&v| -v).collect(); Matrix { cols: self.cols, inner, } } } impl Add for &Matrix { type Output = Matrix; fn add(self, other: Self) -> Matrix { let self_iter = self.inner.iter(); let inner = self_iter .zip(other.inner.iter()) .map(|(&u, &v)| u + v) .collect(); Matrix { cols: self.cols, inner, } } } impl Sub for &Matrix { type Output = Matrix; fn sub(self, other: Self) -> Matrix { let self_iter = self.inner.iter(); let inner = self_iter .zip(other.inner.iter()) .map(|(&u, &v)| u - v) .collect(); Matrix { cols: self.cols, inner, } } } impl Mul<f64> for &Matrix { type Output = Matrix; fn mul(self, scalar: f64) -> Matrix { let inner = self.inner.iter().map(|&v| v * scalar).collect(); Matrix { cols: self.cols, inner, } } } impl Mul for &Matrix { type Output = Matrix; fn mul(self, other: Self) -> Matrix { assert_eq!(self.cols, other.rows()); let mut matrix = Matrix::zero(self.rows(), other.cols); for i in 0..self.rows() { for k in 0..self.cols { for j in 0..other.cols { matrix[i][j] += self[i][k] * other[k][j]; } } } matrix } } } pub fn extended_gcd(a: i64, b: i64) -> (i64, i64, i64) { if b == 0 { (a.abs(), a.signum(), 0) } else { let (d, coef_b, coef_a) = extended_gcd(b, a % b); (d, coef_a, coef_b - coef_a * (a / b)) } } pub fn canon_egcd(a: i64, b: i64, c: i64) -> Option<(i64, i64, i64)> { let (d, _, coef_b_init) = extended_gcd(a, b); if c % d == 0 { let a_d = (a / d).abs(); let coef_b = (coef_b_init * (c / d) % a_d + a_d) % a_d; let coef_a = (c - b * coef_b) / a; Some((d, coef_a, coef_b)) } else { None } } fn pos_mod(n: i64, m: i64) -> i64 { if n < 0 { n + m } else { n } } fn mod_mul(a: i64, b: i64, m: i64) -> i64 { pos_mod((a as i128 * b as i128 % m as i128) as i64, m) } fn mod_exp(mut base: i64, mut exp: u64, m: i64) -> i64 { assert!(m >= 1); let mut ans = 1 % m; base %= m; while exp > 0 { if exp % 2 == 1 { ans = mod_mul(ans, base, m); } base = mod_mul(base, base, m); exp /= 2; } pos_mod(ans, m) } fn is_strong_probable_prime(n: i64, exp: u64, r: i64, a: i64) -> bool { let mut x = mod_exp(a, exp, n); if x == 1 || x == n - 1 { return true; } for _ in 1..r { x = mod_mul(x, x, n); if x == n - 1 { return true; } } false } pub fn is_prime(n: i64) -> bool { const BASES: [i64; 12] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]; assert!(n >= 0); match n { 0 | 1 => false, 2 | 3 => true, _ if n % 2 == 0 => false, _ => { let r = (n - 1).trailing_zeros() as i64; let exp = (n - 1) as u64 >> r; BASES .iter() .all(|&base| base > n - 2 || is_strong_probable_prime(n, exp, r, base)) } } } fn pollard_rho(n: i64) -> i64 { for a in 1..n { let f = |x| pos_mod(mod_mul(x, x, n) + a, n); let mut x = 2; let mut y = 2; loop { x = f(x); y = f(f(y)); let div = num::fast_gcd(x - y, n); if div == n { break; } else if div > 1 { return div; } } } panic!("No divisor found!"); } pub fn factorize(n: i64) -> Vec<i64> { assert!(n >= 1); let r = n.trailing_zeros() as usize; let mut factors = vec![2; r]; let mut stack = match n >> r { 1 => vec![], x => vec![x], }; while let Some(top) = stack.pop() { if is_prime(top) { factors.push(top); } else { let div = pollard_rho(top); stack.push(div); stack.push(top / div); } } factors.sort_unstable(); factors } } pub mod order { pub fn asserting_cmp<T: PartialOrd>(a: &T, b: &T) -> std::cmp::Ordering { a.partial_cmp(b).expect("Comparing incomparable elements") } pub fn slice_lower_bound<T: PartialOrd>(slice: &[T], key: &T) -> usize { slice .binary_search_by(|x| asserting_cmp(x, key).then(std::cmp::Ordering::Greater)) .unwrap_err() } pub fn slice_upper_bound<T: PartialOrd>(slice: &[T], key: &T) -> usize { slice .binary_search_by(|x| asserting_cmp(x, key).then(std::cmp::Ordering::Less)) .unwrap_err() } pub fn merge_sorted<T: PartialOrd>( i1: impl IntoIterator<Item = T>, i2: impl IntoIterator<Item = T>, ) -> Vec<T> { let mut i1 = i1.into_iter().peekable(); let mut i2 = i2.into_iter().peekable(); let mut merged = Vec::with_capacity(i1.size_hint().0 + i2.size_hint().0); while let (Some(a), Some(b)) = (i1.peek(), i2.peek()) { merged.push(if a <= b { i1.next() } else { i2.next() }.unwrap()); } merged.extend(i1.chain(i2)); merged } pub fn merge_sort<T: Ord>(mut v: Vec<T>) -> Vec<T> { if v.len() < 2 { v } else { let v2 = v.split_off(v.len() / 2); merge_sorted(merge_sort(v), merge_sort(v2)) } } pub struct SparseIndex { coords: Vec<i64>, } impl SparseIndex { pub fn new(mut coords: Vec<i64>) -> Self { coords.sort_unstable(); coords.dedup(); Self { coords } } pub fn compress(&self, q: i64) -> Result<usize, usize> { self.coords.binary_search(&q) } } #[derive(Default)] pub struct PiecewiseLinearConvexFn { recent_lines: Vec<(f64, f64)>, sorted_lines: Vec<(f64, f64)>, intersections: Vec<f64>, amortized_work: usize, } impl PiecewiseLinearConvexFn { pub fn max_with(&mut self, new_m: f64, new_b: f64) { self.recent_lines.push((new_m, new_b)); } fn max_with_sorted(&mut self, new_m: f64, new_b: f64) { while let Some(&(last_m, last_b)) = self.sorted_lines.last() { if (new_m - last_m).abs() > 1e-9 { let intersect = (new_b - last_b) / (last_m - new_m); if self.intersections.last() < Some(&intersect) { self.intersections.push(intersect); break; } } self.intersections.pop(); self.sorted_lines.pop(); } self.sorted_lines.push((new_m, new_b)); } fn eval_unoptimized(&self, x: f64) -> f64 { let idx = slice_lower_bound(&self.intersections, &x); self.recent_lines .iter() .chain(self.sorted_lines.get(idx)) .map(|&(m, b)| m * x + b) .max_by(asserting_cmp) .unwrap_or(-1e18) } pub fn evaluate(&mut self, x: f64) -> f64 { self.amortized_work += self.recent_lines.len(); if self.amortized_work > self.sorted_lines.len() { self.amortized_work = 0; self.recent_lines.sort_unstable_by(asserting_cmp); self.intersections.clear(); let all_lines = merge_sorted(self.recent_lines.drain(..), self.sorted_lines.drain(..)); for (new_m, new_b) in all_lines { self.max_with_sorted(new_m, new_b); } } self.eval_unoptimized(x) } } } pub mod range_query { pub mod dynamic_arq { use super::ArqSpec; pub struct DynamicArqNode<T: ArqSpec> { val: T::S, app: Option<T::F>, down: (usize, usize), } impl<T: ArqSpec> Clone for DynamicArqNode<T> { fn clone(&self) -> Self { Self { val: self.val.clone(), app: self.app.clone(), down: self.down, } } } impl<T: ArqSpec> Default for DynamicArqNode<T> { fn default() -> Self { Self { val: T::identity(), app: None, down: (usize::max_value(), usize::max_value()), } } } impl<T: ArqSpec> DynamicArqNode<T> { fn apply(&mut self, f: &T::F, size: i64) { self.val = T::apply(f, &self.val, size); if size > 1 { let h = match self.app { Some(ref g) => T::compose(f, g), None => f.clone(), }; self.app = Some(h); } } } pub type ArqView = (usize, i64); pub struct DynamicArq<T: ArqSpec> { nodes: Vec<DynamicArqNode<T>>, is_persistent: bool, } impl<T: ArqSpec> DynamicArq<T> { pub fn new(is_persistent: bool) -> Self { Self { nodes: vec![], is_persistent, } } pub fn build_from_identity(&mut self, size: i64) -> ArqView { self.nodes.push(DynamicArqNode::default()); (self.nodes.len() - 1, size) } pub fn build_from_slice(&mut self, init_val: &[T::S]) -> ArqView { if init_val.len() == 1 { let root = DynamicArqNode { val: init_val[0].clone(), ..Default::default() }; self.nodes.push(root); (self.nodes.len() - 1, 1) } else { let ls = init_val.len() / 2; let (l_init, r_init) = init_val.split_at(ls); let l_view = self.build_from_slice(l_init); let r_view = self.build_from_slice(r_init); self.merge_equal_sized(l_view, r_view) } } pub fn merge_equal_sized( &mut self, (lp, ls): ArqView, (rp, rs): ArqView, ) -> ArqView { assert!(ls == rs || ls + 1 == rs); let p = self.nodes.len(); let root = DynamicArqNode { down: (lp, rp), ..Default::default() }; self.nodes.push(root); self.pull(p); (p, ls + rs) } pub fn push(&mut self, (p, s): ArqView) -> (ArqView, ArqView) { if self.nodes[p].down.0 == usize::max_value() { self.nodes.push(DynamicArqNode::default()); self.nodes.push(DynamicArqNode::default()); self.nodes[p].down = (self.nodes.len() - 2, self.nodes.len() - 1) }; let (lp, rp) = self.nodes[p].down; let ls = s / 2; if let Some(ref f) = self.nodes[p].app.take() { self.nodes[lp].apply(f, ls); self.nodes[rp].apply(f, s - ls); } ((lp, ls), (rp, s - ls)) } pub fn pull(&mut self, p: usize) { let (lp, rp) = self.nodes[p].down; let left_val = &self.nodes[lp].val; let right_val = &self.nodes[rp].val; self.nodes[p].val = T::op(left_val, right_val); } fn clone_node(&mut self, p_orig: usize) -> usize { if self.is_persistent { let node = self.nodes[p_orig].clone(); self.nodes.push(node); self.nodes.len() - 1 } else { p_orig } } pub fn update(&mut self, view: ArqView, l: i64, r: i64, f: &T::F) -> ArqView { let (p_orig, s) = view; if r < 0 || s - 1 < l { view } else if l <= 0 && s - 1 <= r { let p_clone = self.clone_node(p_orig); self.nodes[p_clone].apply(f, s); (p_clone, s) } else { let (l_view, r_view) = self.push(view); let ls = l_view.1; let p_clone = self.clone_node(p_orig); let lp_clone = self.update(l_view, l, r, f).0; let rp_clone = self.update(r_view, l - ls, r - ls, f).0; self.nodes[p_clone].down = (lp_clone, rp_clone); self.pull(p_clone); (p_clone, s) } } pub fn query(&mut self, view: ArqView, l: i64, r: i64) -> T::S { let (p, s) = view; if r < 0 || s - 1 < l { T::identity() } else if l <= 0 && s - 1 <= r { self.nodes[p].val.clone() } else { let (l_view, r_view) = self.push(view); let ls = l_view.1; let l_agg = self.query(l_view, l, r); let r_agg = self.query(r_view, l - ls, r - ls); T::op(&l_agg, &r_agg) } } } pub fn first_negative( arq: &mut DynamicArq<super::specs::AssignMin>, view: ArqView, ) -> Option<i64> { let (p, s) = view; if s == 1 { Some(0).filter(|_| arq.nodes[p].val < 0) } else { let (l_view, r_view) = arq.push(view); let (lp, ls) = l_view; if arq.nodes[lp].val < 0 { first_negative(arq, l_view) } else { first_negative(arq, r_view).map(|x| ls + x) } } } } pub mod specs { pub trait ArqSpec { type S: Clone; type F: Clone; fn op(a: &Self::S, b: &Self::S) -> Self::S; fn identity() -> Self::S; fn compose(f: &Self::F, g: &Self::F) -> Self::F; fn apply(f: &Self::F, a: &Self::S, size: i64) -> Self::S; } pub enum AssignMin {} impl ArqSpec for AssignMin { type S = i64; type F = i64; fn op(&a: &Self::S, &b: &Self::S) -> Self::S { a.min(b) } fn identity() -> Self::S { i64::max_value() } fn compose(&f: &Self::F, _: &Self::F) -> Self::F { f } fn apply(&f: &Self::F, _: &Self::S, _: i64) -> Self::S { f } } pub enum AssignSum {} impl ArqSpec for AssignSum { type S = i64; type F = i64; fn op(&a: &Self::S, &b: &Self::S) -> Self::S { a + b } fn identity() -> Self::S { 0 } fn compose(&f: &Self::F, _: &Self::F) -> Self::F { f } fn apply(&f: &Self::F, _: &Self::S, size: i64) -> Self::S { f * size } } pub enum SupplyDemand {} impl ArqSpec for SupplyDemand { type S = (i64, i64, i64); type F = (i64, i64); fn op((p1, o1, s1): &Self::S, (p2, o2, s2): &Self::S) -> Self::S { let extra = (p1 - s1).min(o2 - s2); (p1 + p2, o1 + o2, s1 + s2 + extra) } fn identity() -> Self::S { (0, 0, 0) } fn compose(_: &Self::F, _: &Self::F) -> Self::F { unimplemented!() } fn apply(&(p_add, o_add): &Self::F, &(p, o, _): &Self::S, s: i64) -> Self::S { assert_eq!(s, 1); let p = p + p_add; let o = o + o_add; (p, o, p.min(o)) } } } pub mod sqrt_decomp { pub trait MoState { type Q; type A; const L_R_RATIO: f64 = 1.0; fn query(&self, q: &Self::Q) -> Self::A; fn insert_left(&mut self, pos: usize); fn remove_left(&mut self, pos: usize); fn insert_right(&mut self, pos: usize) { self.insert_left(pos); } fn remove_right(&mut self, pos: usize) { self.remove_left(pos); } fn process(&mut self, queries: &[(usize, usize, Self::Q)]) -> Vec<Self::A> { let q = queries.len(); let mut q_positions: Vec<usize> = (0..q).collect(); if let Some(max_r) = queries.iter().map(|&(_, r, _)| r).max() { let q_adjusted = q as f64 * Self::L_R_RATIO; let bucket_width = 1 + max_r / q_adjusted.sqrt() as usize; q_positions.sort_unstable_by_key(|&i| { let (l, mut r) = (queries[i].0, queries[i].1); let bucket = l / bucket_width; if bucket % 2 != 0 { r = max_r - r; } (bucket, r) }); } let (mut cur_l, mut cur_r) = (1, 0); let mut answers = Vec::with_capacity(queries.len()); for i in q_positions { let (l, r, ref q) = queries[i]; while cur_l > l { cur_l -= 1; self.insert_left(cur_l); } while cur_r < r { cur_r += 1; self.insert_right(cur_r); } while cur_l < l { self.remove_left(cur_l); cur_l += 1; } while cur_r > r { self.remove_right(cur_r); cur_r -= 1; } answers.push((i, self.query(q))); } answers.sort_unstable_by_key(|&(i, _)| i); answers.into_iter().map(|(_, ans)| ans).collect() } } pub struct DistinctVals { vals: Vec<usize>, counts: Vec<usize>, distinct: usize, } impl DistinctVals { pub fn new(vals: Vec<usize>) -> Self { let &max_val = vals.iter().max().unwrap_or(&0); Self { vals, counts: vec![0; max_val + 1], distinct: 0, } } } impl MoState for DistinctVals { type Q = (); type A = usize; fn query(&self, _: &Self::Q) -> Self::A { self.distinct } fn insert_left(&mut self, pos: usize) { let v = self.vals[pos]; if self.counts[v] == 0 { self.distinct += 1; } self.counts[v] += 1; } fn remove_left(&mut self, pos: usize) { let v = self.vals[pos]; self.counts[v] -= 1; if self.counts[v] == 0 { self.distinct -= 1; } } } } pub mod static_arq { use super::ArqSpec; pub struct StaticArq<T: ArqSpec> { val: Vec<T::S>, app: Vec<Option<T::F>>, } impl<T: ArqSpec> StaticArq<T> { pub fn new(init_val: &[T::S]) -> Self { let size = init_val.len(); let mut val = vec![T::identity(); size]; val.extend_from_slice(init_val); let app = vec![None; size]; let mut arq = Self { val, app }; for p in (0..size).rev() { arq.pull(p); } arq } fn apply(&mut self, p: usize, f: &T::F, s: i64) { self.val[p] = T::apply(f, &self.val[p], s); if let Some(lazy) = self.app.get_mut(p) { let h = match *lazy { Some(ref g) => T::compose(f, g), None => f.clone(), }; *lazy = Some(h); } } fn push(&mut self, p: usize) { if let Some(ref f) = self.app[p].take() { let s = ((self.app.len() + p - 1) / p / 2).next_power_of_two() as i64; self.apply(p << 1, f, s); self.apply(p << 1 | 1, f, s); } } fn pull(&mut self, p: usize) { self.val[p] = T::op(&self.val[p << 1], &self.val[p << 1 | 1]); } fn push_to(&mut self, p: usize) { let one_plus_floor_log_p = (p + 1).next_power_of_two().trailing_zeros(); for i in (1..one_plus_floor_log_p).rev() { self.push(p >> i); } } fn pull_from(&mut self, mut p: usize) { while p > 1 { p >>= 1; self.pull(p); } } pub fn update(&mut self, mut l: usize, mut r: usize, f: &T::F) { l += self.app.len(); r += self.app.len(); if l < r { self.push_to(l); } self.push_to(r); let (mut l0, mut r0, mut s) = (1, 1, 1); while l <= r { if l & 1 == 1 { self.apply(l, f, s); l0 = l0.max(l); l += 1; } if r & 1 == 0 { self.apply(r, f, s); r0 = r0.max(r); r -= 1; } l >>= 1; r >>= 1; s <<= 1; } self.pull_from(l0); self.pull_from(r0); } pub fn query(&mut self, mut l: usize, mut r: usize) -> T::S { l += self.app.len(); r += self.app.len(); if l < r { self.push_to(l); } self.push_to(r); let (mut l_agg, mut r_agg) = (T::identity(), T::identity()); while l <= r { if l & 1 == 1 { l_agg = T::op(&l_agg, &self.val[l]); l += 1; } if r & 1 == 0 { r_agg = T::op(&self.val[r], &r_agg); r -= 1; } l >>= 1; r >>= 1; } T::op(&l_agg, &r_agg) } } pub fn first_negative(arq: &mut StaticArq<super::specs::AssignMin>) -> Option<usize> { assert!(arq.app.len().is_power_of_two()); let mut p = 1; if arq.val[p] >= 0 { None } else { while p < arq.app.len() { arq.push(p); p <<= 1; if arq.val[p] >= 0 { p |= 1; } } Some(p - arq.app.len()) } } } pub use self::dynamic_arq::{ArqView, DynamicArq}; pub use self::specs::ArqSpec; pub use self::static_arq::StaticArq; } pub mod rng { pub type SmallRng = Xoshiro256PlusPlus; #[derive(Debug, Clone, PartialEq, Eq)] pub struct Xoshiro256PlusPlus { s: [u64; 4], } impl Xoshiro256PlusPlus { pub fn new(mut state: u64) -> Self { const PHI: u64 = 0x9e3779b97f4a7c15; let mut seed = <[u64; 4]>::default(); for chunk in &mut seed { state = state.wrapping_add(PHI); let mut z = state; z = (z ^ (z >> 30)).wrapping_mul(0xbf58476d1ce4e5b9); z = (z ^ (z >> 27)).wrapping_mul(0x94d049bb133111eb); z = z ^ (z >> 31); *chunk = z; } Self { s: seed } } #[inline] pub fn next_u32(&mut self) -> u32 { (self.next_u64() >> 32) as u32 } #[inline] pub fn next_u64(&mut self) -> u64 { let result_plusplus = self.s[0] .wrapping_add(self.s[3]) .rotate_left(23) .wrapping_add(self.s[0]); let t = self.s[1] << 17; self.s[2] ^= self.s[0]; self.s[3] ^= self.s[1]; self.s[1] ^= self.s[2]; self.s[0] ^= self.s[3]; self.s[2] ^= t; self.s[3] = self.s[3].rotate_left(45); result_plusplus } } } pub mod scanner { use std::io; use std::str; pub struct Scanner<R> { reader: R, buffer: Vec<String>, } impl<R: io::BufRead> Scanner<R> { pub fn new(reader: R) -> Self { Self { reader, buffer: vec![], } } pub fn token<T: str::FromStr>(&mut self) -> T { loop { if let Some(token) = self.buffer.pop() { return token.parse().ok().expect("Failed parse"); } let mut input = String::new(); self.reader.read_line(&mut input).expect("Failed read"); self.buffer = input.split_whitespace().rev().map(String::from).collect(); } } } pub struct UnsafeScanner<R> { reader: R, buf_str: Vec<u8>, buf_iter: str::SplitAsciiWhitespace<'static>, } impl<R: io::BufRead> UnsafeScanner<R> { pub fn new(reader: R) -> Self { Self { reader, buf_str: vec![], buf_iter: "".split_ascii_whitespace(), } } pub fn token<T: str::FromStr>(&mut self) -> T { loop { if let Some(token) = self.buf_iter.next() { return token.parse().ok().expect("Failed parse"); } self.buf_str.clear(); self.reader .read_until(b'\n', &mut self.buf_str) .expect("Failed read"); self.buf_iter = unsafe { let slice = str::from_utf8_unchecked(&self.buf_str); std::mem::transmute(slice.split_ascii_whitespace()) } } } } pub fn scanner_from_file(filename: &str) -> Scanner<io::BufReader<std::fs::File>> { let file = std::fs::File::open(filename).expect("Input file not found"); Scanner::new(io::BufReader::new(file)) } pub fn writer_to_file(filename: &str) -> io::BufWriter<std::fs::File> { let file = std::fs::File::create(filename).expect("Output file not found"); io::BufWriter::new(file) } } pub mod printer {} pub mod string_proc { use std::cmp::{max, min}; use std::collections::{hash_map::Entry, HashMap, VecDeque}; pub struct Trie<C: std::hash::Hash + Eq> { links: Vec<HashMap<C, usize>>, } impl<C: std::hash::Hash + Eq> Default for Trie<C> { fn default() -> Self { Self { links: vec![HashMap::new()], } } } impl<C: std::hash::Hash + Eq> Trie<C> { pub fn insert(&mut self, word: impl IntoIterator<Item = C>) -> usize { let mut node = 0; for ch in word { let len = self.links.len(); node = match self.links[node].entry(ch) { Entry::Occupied(entry) => *entry.get(), Entry::Vacant(entry) => { entry.insert(len); self.links.push(HashMap::new()); len } } } node } pub fn get(&self, word: impl IntoIterator<Item = C>) -> Option<usize> { let mut node = 0; for ch in word { node = *self.links[node].get(&ch)?; } Some(node) } } pub struct Matcher<'a, C: Eq> { pub pattern: &'a [C], pub fail: Vec<usize>, } impl<'a, C: Eq> Matcher<'a, C> { pub fn new(pattern: &'a [C]) -> Self { let mut fail = Vec::with_capacity(pattern.len()); fail.push(0); let mut len = 0; for ch in &pattern[1..] { while len > 0 && pattern[len] != *ch { len = fail[len - 1]; } if pattern[len] == *ch { len += 1; } fail.push(len); } Self { pattern, fail } } pub fn kmp_match(&self, text: impl IntoIterator<Item = C>) -> Vec<usize> { let mut len = 0; text.into_iter() .map(|ch| { if len == self.pattern.len() { len = self.fail[len - 1]; } while len > 0 && self.pattern[len] != ch { len = self.fail[len - 1]; } if self.pattern[len] == ch { len += 1; } len }) .collect() } } pub struct MultiMatcher<C: std::hash::Hash + Eq> { pub trie: Trie<C>, pub pat_id: Vec<Option<usize>>, pub fail: Vec<usize>, pub fast: Vec<usize>, } impl<C: std::hash::Hash + Eq> MultiMatcher<C> { fn next(trie: &Trie<C>, fail: &[usize], mut node: usize, ch: &C) -> usize { loop { if let Some(&child) = trie.links[node].get(ch) { return child; } else if node == 0 { return 0; } node = fail[node]; } } pub fn new(patterns: impl IntoIterator<Item = impl IntoIterator<Item = C>>) -> Self { let mut trie = Trie::default(); let pat_nodes: Vec<usize> = patterns.into_iter().map(|pat| trie.insert(pat)).collect(); let mut pat_id = vec![None; trie.links.len()]; for (i, node) in pat_nodes.into_iter().enumerate() { pat_id[node] = Some(i); } let mut fail = vec![0; trie.links.len()]; let mut fast = vec![0; trie.links.len()]; let mut q: VecDeque<usize> = trie.links[0].values().cloned().collect(); while let Some(node) = q.pop_front() { for (ch, &child) in &trie.links[node] { let nx = Self::next(&trie, &fail, fail[node], &ch); fail[child] = nx; fast[child] = if pat_id[nx].is_some() { nx } else { fast[nx] }; q.push_back(child); } } Self { trie, pat_id, fail, fast, } } pub fn ac_match(&self, text: impl IntoIterator<Item = C>) -> Vec<usize> { let mut node = 0; text.into_iter() .map(|ch| { node = Self::next(&self.trie, &self.fail, node, &ch); node }) .collect() } pub fn get_end_pos_and_pat_id(&self, match_nodes: &[usize]) -> Vec<(usize, usize)> { let mut res = vec![]; for (text_pos, &(mut node)) in match_nodes.iter().enumerate() { while node != 0 { if let Some(id) = self.pat_id[node] { res.push((text_pos + 1, id)); } node = self.fast[node]; } } res } } pub struct SuffixArray { pub sfx: Vec<usize>, pub rank: Vec<Vec<usize>>, } impl SuffixArray { fn counting_sort( vals: impl Iterator<Item = usize> + Clone, val_to_key: &[usize], max_key: usize, ) -> Vec<usize> { let mut counts = vec![0; max_key]; for v in vals.clone() { counts[val_to_key[v]] += 1; } let mut total = 0; for c in counts.iter_mut() { total += *c; *c = total - *c; } let mut result = vec![0; total]; for v in vals { let c = &mut counts[val_to_key[v]]; result[*c] = v; *c += 1; } result } pub fn new(text: impl IntoIterator<Item = u8>) -> Self { let init_rank = text.into_iter().map(|ch| ch as usize).collect::<Vec<_>>(); let n = init_rank.len(); let mut sfx = Self::counting_sort(0..n, &init_rank, 256); let mut rank = vec![init_rank]; for skip in (0..).map(|i| 1 << i).take_while(|&skip| skip < n) { let prev_rank = rank.last().unwrap(); let mut cur_rank = prev_rank.clone(); let pos = (n - skip..n).chain(sfx.into_iter().filter_map(|p| p.checked_sub(skip))); sfx = Self::counting_sort(pos, &prev_rank, max(n, 256)); let mut prev = sfx[0]; cur_rank[prev] = 0; for &cur in sfx.iter().skip(1) { if max(prev, cur) + skip < n && prev_rank[prev] == prev_rank[cur] && prev_rank[prev + skip] == prev_rank[cur + skip] { cur_rank[cur] = cur_rank[prev]; } else { cur_rank[cur] = cur_rank[prev] + 1; } prev = cur; } rank.push(cur_rank); } Self { sfx, rank } } pub fn longest_common_prefix(&self, mut i: usize, mut j: usize) -> usize { let mut len = 0; for (k, rank) in self.rank.iter().enumerate().rev() { if rank[i] == rank[j] { i += 1 << k; j += 1 << k; len += 1 << k; if max(i, j) >= self.sfx.len() { break; } } } len } } pub fn palindromes(text: &[impl Eq]) -> Vec<usize> { let mut pal = Vec::with_capacity(2 * text.len() - 1); pal.push(1); while pal.len() < pal.capacity() { let i = pal.len() - 1; let max_len = min(i + 1, pal.capacity() - i); while pal[i] < max_len && text[(i - pal[i] - 1) / 2] == text[(i + pal[i] + 1) / 2] { pal[i] += 2; } if let Some(a) = 1usize.checked_sub(pal[i]) { pal.push(a); } else { for d in 1.. { let (a, b) = (pal[i - d], pal[i] - d); if a < b { pal.push(a); } else { pal.push(b); break; } } } } pal } pub fn z_algorithm(text: &[impl Eq]) -> Vec<usize> { let n = text.len(); let (mut l, mut r) = (1, 1); let mut z = Vec::with_capacity(n); z.push(n); for i in 1..n { if r > i + z[i - l] { z.push(z[i - l]); } else { l = i; while r < i || (r < n && text[r - i] == text[r]) { r += 1; } z.push(r - i); } } z } } } use algo::scanner::UnsafeScanner; static mut SCANNER: MaybeUninit<UnsafeScanner<io::StdinLock>> = MaybeUninit::uninit(); static mut WRITER: MaybeUninit<io::BufWriter<io::StdoutLock>> = MaybeUninit::uninit(); pub const YES: &str = "YES"; pub const NO: &str = "NO"; pub fn init() { unsafe { let scanner = UnsafeScanner::new(transmute::<StdinLock, StdinLock<'static>>( io::stdin().lock(), )); SCANNER.as_mut_ptr().write(scanner); let writer = io::BufWriter::new(transmute::<io::StdoutLock, io::StdoutLock<'static>>( io::stdout().lock(), )); WRITER.as_mut_ptr().write(writer); } } #[inline(always)] pub fn __scanner() -> &'static mut UnsafeScanner<io::StdinLock<'static>> { unsafe { &mut *SCANNER.as_mut_ptr() } } #[inline(always)] pub fn __writer() -> &'static mut io::BufWriter<io::StdoutLock<'static>> { unsafe { &mut *WRITER.as_mut_ptr() } } pub fn flush() { __writer().flush().unwrap(); } #[macro_export] macro_rules! main { (multi) => { fn main() { $crate::init(); input!(t: usize); for _ in 0..t { solve(); } $crate::flush(); } }; (multi , intr) => { fn main() { $crate::init(); input!(t: usize); for _ in 0..t { solve(); $crate::flush(); } } }; () => { fn main() { $crate::init(); solve(); $crate::flush(); } }; } #[macro_export] macro_rules! flush { () => { $crate::flush(); }; } #[macro_export] macro_rules ! input { ($ ($ r : tt) *) => { let sc = $ crate :: __scanner () ; input_inner ! { sc , $ ($ r) * } } ; } #[macro_export] macro_rules ! input_inner { ($ sc : expr) => { } ; ($ sc : expr ,) => { } ; ($ sc : expr , $ var : ident : $ t : tt $ ($ r : tt) *) => { # [allow (unused_mut)] let mut $ var = read_value ! ($ sc , $ t) ; input_inner ! { $ sc $ ($ r) * } } ; } #[macro_export] macro_rules ! read_value { ($ sc : expr , ($ ($ t : tt) ,*)) => { ($ (read_value ! ($ sc , $ t)) ,*) } ; ($ sc : expr , [$ t : tt ; $ len : expr]) => { (0 ..$ len) . map (| _ | read_value ! ($ sc , $ t)) . collect ::< Vec < _ >> () } ; ($ sc : expr , chars) => { read_value ! ($ sc , String) . chars () . collect ::< Vec < char >> () } ; ($ sc : expr , bytes) => { read_value ! ($ sc , String) . into_bytes () } ; ($ sc : expr , usize1) => { read_value ! ($ sc , usize) - 1 } ; ($ sc : expr , $ t : ty) => { $ sc . token ::<$ t > () } ; } #[macro_export] macro_rules ! println { ($ ($ args : tt) *) => { { use std :: io :: Write ; writeln ! ($ crate :: __writer () , $ ($ args) *) . unwrap () } } ; } #[macro_export] macro_rules ! print { ($ ($ args : tt) *) => { { use std :: io :: Write ; write ! ($ crate :: __writer () , $ ($ args) *) . unwrap () } } ; } #[macro_export] macro_rules ! out { () => { } ; ($ e : expr) => { print ! ("{}" , $ e) ; } ; ($ e : expr , $ ($ es : expr) ,*) => { out ! ($ e) ; out ! (" ") ; out ! ($ ($ es) ,*) ; } ; } #[macro_export] macro_rules ! outln { ($ ($ args : tt) *) => { { out ! ($ ($ args) *) ; println ! () ; } } ; } pub fn out_spaced<T: Display>(it: impl IntoIterator<Item = T>) { for v in it { print!("{} ", v); } } pub fn out_lined<T: Display>(it: impl IntoIterator<Item = T>) { for v in it { println!("{}", v); } } pub fn yn(yes: bool) -> &'static str { if yes { "YES" } else { "NO" } } #[macro_export] macro_rules ! ans { ($ ($ args : tt) *) => { output ! ($ ($ args) *) ; return ; } ; } #[macro_export] macro_rules ! output { (; $ ($ r : tt) *) => { println ! () ; output ! ($ ($ r) *) ; } ; ($ x : expr ,* $ ($ r : tt) *) => { $ crate :: out_spaced ($ x) ; output ! ($ ($ r) *) ; } ; ($ x : expr ;* $ ($ r : tt) *) => { $ crate :: out_lined ($ x) ; output ! ($ ($ r) *) ; } ; ($ x : expr , $ ($ r : tt) *) => { out ! ($ x) ; print ! (" ") ; output ! ($ ($ r) *) ; } ; ($ x : expr ; $ ($ r : tt) *) => { out ! ($ x) ; println ! () ; output ! ($ ($ r) *) ; } ; ($ x : expr) => { print ! ("{}" , $ x) ; } ; () => { } ; } #[macro_export] macro_rules ! cmp_go { (@ go $ a : ident , $ b : ident , .$ x : tt , $ ($ tt : tt) *) => { match ($ a .$ x) . cmp (& ($ b .$ x)) { std :: cmp :: Ordering :: Equal => cmp_go ! (@ go $ a , $ b , $ ($ tt) *) , ordering => ordering } } ; (@ go $ a : ident , $ b : ident , .$ x : tt) => { cmp_go ! (@ go $ a , $ b , .$ x ,) } ; (@ go $ a : ident , $ b : ident , $ x : expr ,) => { cmp_go ! (@ go $ a , $ b , $ x ,) } ; (@ go $ a : ident , $ b : ident , $ x : expr , $ ($ tt : tt) *) => { match $ x { mut x => match (x ($ a)) . cmp (& (x (&$ b))) { std :: cmp :: Ordering :: Equal => cmp_go ! (@ go $ a , $ b , $ ($ tt) *) , ordering => ordering } } } ; (@ go $ a : ident , $ b : ident , $ x : tt , $ ($ tt : tt) *) => { match ($ x ($ a)) . cmp (& ($ x (&$ b))) { std :: cmp :: Ordering :: Equal => cmp_go ! (@ go $ a , $ b , $ ($ tt) *) , ordering => ordering } } ; (@ go $ a : ident , $ b : ident ,) => { std :: cmp :: Ordering :: Equal } ; } #[macro_export(local_inner_macros)] macro_rules ! cmp { ($ ($ tt : tt) *) => { | a , b | { cmp_go ! (@ go a , b , $ ($ tt) *) } } ; } pub trait IExt { fn i(self) -> i64; } impl IExt for usize { fn i(self) -> i64 { self as i64 } } pub trait UExt { fn u(self) -> usize; } impl UExt for usize { fn u(self) -> usize { self } } impl UExt for i64 { fn u(self) -> usize { self as usize } } impl UExt for i32 { fn u(self) -> usize { self as usize } }  
